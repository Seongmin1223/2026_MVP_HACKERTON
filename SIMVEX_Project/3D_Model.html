<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SIMVEX - Bright Matte Viewer</title>
    <style>
        :root { --bg-dark: #0f1014; --bg-panel: rgba(20, 22, 28, 0.9); --accent-color: #3b82f6; --text-main: #ffffff; --border-color: #27272a; }
        body { margin: 0; overflow: hidden; background-color: var(--bg-dark); color: var(--text-main); font-family: 'Pretendard', sans-serif; }
        #app-container { display: grid; grid-template-rows: 60px 1fr; grid-template-columns: 1fr 350px; height: 100vh; width: 100vw; }
        header { grid-column: 1 / -1; background: var(--bg-dark); border-bottom: 1px solid var(--border-color); display: flex; align-items: center; justify-content: space-between; padding: 0 24px; font-weight: bold; z-index: 10; }
        #theme-toggle { background: #27272a; border: 1px solid #3f3f46; color: white; padding: 6px 14px; border-radius: 20px; cursor: pointer; font-size: 0.8rem; }
        #viewport { position: relative; overflow: hidden; width: 100%; height: 100%; }
        #viewport.dark-bg { background: radial-gradient(circle at center, #1e293b 0%, #0f172a 100%); }
        #viewport.light-bg { background: radial-gradient(circle at center, #f8fafc 0%, #cbd5e1 100%); }
        #viewport-overlay { position: absolute; bottom: 20px; left: 20px; background: rgba(0,0,0,0.6); padding: 12px 16px; border-radius: 8px; pointer-events: none; font-size: 0.85rem; color: #ccc; backdrop-filter: blur(4px); border: 1px solid rgba(255,255,255,0.1); z-index: 100; }
        .kbd { background: #333; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; color: white; border-bottom: 2px solid #111; font-family: monospace; }
        aside { background: var(--bg-panel); border-left: 1px solid var(--border-color); padding: 24px; display: flex; flex-direction: column; gap: 24px; overflow-y: auto; }
        h3 { margin: 0 0 12px 0; font-size: 0.9rem; color: var(--accent-color); text-transform: uppercase; }
        .slider-container { margin-top: 10px; display: flex; align-items: center; gap: 10px; }
        input[type=range] { flex-grow: 1; accent-color: var(--accent-color); cursor: pointer; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--accent-color); font-size: 1.2rem; font-weight: bold; }
    </style>
</head>
<body>

    <div id="app-container">
        <header>
            <div style="display:flex; align-items:center;">
                <div style="color:#3b82f6; margin-right:20px;">SIMVEX</div> Study
            </div>
            <button id="theme-toggle">â˜€ï¸ Light Background</button>
        </header>
        
        <div id="viewport" class="dark-bg">
            <div id="loading">ë°ì´í„° ë¡œë”© ì¤‘</div>
            <div id="viewport-overlay">
                <div style="font-weight:bold; margin-bottom:6px;">ğŸ® ì¡°ì‘ ê°€ì´ë“œ</div>
                <div>â€¢ <span class="kbd">WASD</span> ì´ë™ / <span class="kbd">ì¢Œí´ë¦­</span> íŒ¨ë‹ / <span class="kbd">ìš°í´ë¦­</span> íšŒì „</div>
            </div>
        </div>
        <aside>
            <div>
                <h3>ğŸ“¦ Part Info</h3>
                <h2 id="part-name" style="margin:0;">Unknown Asset</h2>
                <p id="part-desc" style="color:#a1a1aa; font-size:0.9rem;">ë¶€í’ˆì„ í´ë¦­í•˜ì—¬ ìƒì„¸ ì •ë³´ë¥¼ í™•ì¸í•˜ì„¸ìš”.</p>
            </div>
            <div>
                <h3>ğŸ”§ Exploded View(ë¶„í•´ë„)</h3>
                <div class="slider-container">
                    <span>ì¡°ë¦½</span>
                    <input type="range" id="explode-slider" min="0" max="100" value="0">
                    <span>ë¶„í•´</span>
                </div>
            </div>
        </aside>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';

        // --- [ì„¤ì • ë³€ìˆ˜] ì—¬ê¸°ì„œ ëª¨ë“  ê²ƒì„ ê´€ë¦¬í•˜ì„¸ìš” ---
        const CONFIG = {
            assetName: "V4Engine", // í™•ì¥ì ì œì™¸ íŒŒì¼ ì´ë¦„
            basePath: "./Integrated 3D Asset/",
            get glbPath() { return `${this.basePath}GLB/${this.assetName}.glb`; },
            get jsonPath() { return `${this.basePath}JSON_FILE/Data_${this.assetName}.json`; }
        };

                // 1. ë³€í™˜ ì—†ì´ ì›ë³¸ ì´ë¦„ ì‚¬ìš©
        const assetTitle = CONFIG.assetName || "UnknownAsset";

        // 2. ì•ˆì „í•˜ê²Œ UI ì—…ë°ì´íŠ¸ (ìš”ì†Œê°€ ì—†ì–´ë„ ì—ëŸ¬ê°€ ë‚˜ì§€ ì•ŠìŒ)
        const headerEl = document.getElementById('header-mode-name');
        if (headerEl) {
            headerEl.innerText = `${assetTitle} Mode`;
        }

        const partNameEl = document.getElementById('part-name');
        if (partNameEl) {
            partNameEl.innerText = assetTitle;
        }

        console.log(`í˜„ì¬ ë¡œë“œ ì¤‘ì¸ ì—ì…‹: ${assetTitle}`);

        const container = document.getElementById('viewport');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.001, 1000);
        camera.position.set(0.3, 0.3, 0.3);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.5; // ë°ê²Œ ì„¤ì •
        container.appendChild(renderer.domElement);

        // --- ë°ì€ ì¡°ëª… ì‹œìŠ¤í…œ ---
        scene.add(new THREE.AmbientLight(0xffffff, 1.0));
        scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.8));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(2, 4, 3);
        scene.add(dirLight);

        // --- ì„ íƒ í…Œë‘ë¦¬ íš¨ê³¼ ì„¤ì • ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const outlinePass = new OutlinePass(new THREE.Vector2(container.clientWidth, container.clientHeight), scene, camera);
        outlinePass.edgeStrength = 4.0;
        outlinePass.visibleEdgeColor.set('#3b82f6');
        composer.addPass(outlinePass);

        // --- íŒ¨ë‹ ë° ì»¨íŠ¸ë¡¤ ì„¤ì • ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.screenSpacePanning = true; 
        controls.mouseButtons = { LEFT: THREE.MOUSE.PAN, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.ROTATE };

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let parts = [];
        let uniqueLogicalParts = [];

        // ë°°ê²½ í† ê¸€
        document.getElementById('theme-toggle').addEventListener('click', (e) => {
            const isDark = container.classList.contains('dark-bg');
            container.classList.toggle('dark-bg', !isDark);
            container.classList.toggle('light-bg', isDark);
            e.target.innerText = isDark ? "ğŸŒ™ Dark Background" : "â˜€ï¸ Light Background";
        });

        async function loadAsset() {
            try {
                const res = await fetch(CONFIG.jsonPath);
                const data = await res.json();
                const loader = new GLTFLoader();

                loader.load(CONFIG.glbPath, (gltf) => {
                    const root = gltf.scene;
                    scene.add(root);

                    // ì´ˆê¸°í™”: ìƒˆë¡œìš´ ëª¨ë¸ ë¡œë“œ ì‹œ ê¸°ì¡´ ë°ì´í„° ë¹„ìš°ê¸°
                    uniqueLogicalParts = []; 
                    parts = [];

                    root.traverse(child => {
                        if (child.isMesh) {
                            let current = child;
                            let assetData = null;
                            let logicalPart = null;

                            // ë¶€ëª¨ë¥¼ íƒ€ê³  ì˜¬ë¼ê°€ë©° JSONì˜ IDì™€ ì¼ì¹˜í•˜ëŠ” 'ì§„ì§œ ë¶€í’ˆ' ì°¾ê¸°
                            while (current && current !== root) {
                                assetData = data.assets.find(a => a.id === current.name);
                                if (assetData) {
                                    logicalPart = current;
                                    break;
                                }
                                current = current.parent;
                            }

                            if (logicalPart) {
                                child.userData.logicalPart = logicalPart;
                                child.userData.title = assetData.title || logicalPart.name;
                                child.userData.desc = assetData.desc || "";

                                const ev = assetData.explodeVector
                                logicalPart.userData.manualVector = (ev && (ev.x !== 0 || ev.y !== 0 || ev.z !== 0)) ? new THREE.Vector3(ev.x, ev.y, ev.z) :null;
                                // [ìˆ˜ì •] ìŠ¬ë¼ì´ë”ê°€ ì›€ì§ì¼ ë¶€í’ˆ(Logical Part)ì„ ì¤‘ë³µ ì—†ì´ ìˆ˜ì§‘
                                if (!uniqueLogicalParts.includes(logicalPart)) {
                                    logicalPart.userData.assemblyPos = logicalPart.position.clone();
                                    uniqueLogicalParts.push(logicalPart); 
                                }

                                parts.push(child); // í´ë¦­ì€ ë©”ì‰¬ê°€ ë‹´ë‹¹
                                
                                child.material.metalness = 0;
                                child.material.roughness = 0.6;
                            }
                        }
                    });

                    document.getElementById('loading').style.display = 'none';

                    // [ìˆ˜ì •] ì´ì œ 'parts'ê°€ ì•„ë‹ˆë¼ 'uniqueLogicalParts'ë¥¼ ë„˜ê²¨ì¤ë‹ˆë‹¤.
                    calculateExplosion(uniqueLogicalParts, root); 
                    
                    fitCamera(root);
                });
            } catch (err) { console.error(err); }
        }

        function calculateExplosion(list, root) {
            // [ë³´ì•ˆ] rootê°€ ì œëŒ€ë¡œ ì „ë‹¬ë˜ì§€ ì•Šìœ¼ë©´ ì¤‘ë‹¨ (updateWorldMatrix ì—ëŸ¬ ë°©ì§€)
            if (!root) return; 

            const box = new THREE.Box3().setFromObject(root);
            const center = box.getCenter(new THREE.Vector3());

            list.forEach(p => {
                if (p.userData.manualVector){ //ë²¡í„° ì§€ì •ê°’ì´ ìˆì„ë•Œ
                    p.userData.explodeDir = p.userData.manualVector.clone().normalize();
                }
                else{ //ë²¡í„° ì§€ì •ê°’ì´ ì—†ì„ë•Œ
                    // ê° ë¶€ëª¨ ë¶€í’ˆ(BASE, NUT ë“±)ì˜ ì¤‘ì‹¬ì ì„ êµ¬í•¨
                    const pBox = new THREE.Box3().setFromObject(p);
                    const pCenter = pBox.getCenter(new THREE.Vector3());
                    let dir = new THREE.Vector3().subVectors(pCenter, center);
    
                    // [ì¶”ê°€] ë§Œì•½ ì¤‘ì‹¬ì´ ê²¹ì³ì„œ ë°©í–¥ì´ ì•ˆ ë‚˜ì˜¨ë‹¤ë©´ ëœë¤í•œ ë°©í–¥ì´ë‚˜ ì‚´ì§ ìœ„ë¡œ ì„¤ì •
                    if (dir.length() < 0.0001) {
                        dir.set(Math.random() - 0.5, 0.1, Math.random() - 0.5);
                    }
                    
                    p.userData.explodeDir = dir.normalize();

                }
                
            });
        }

        function fitCamera(object) {
            const box = new THREE.Box3().setFromObject(object);
            const center = box.getCenter(new THREE.Vector3());
            const dist = box.getSize(new THREE.Vector3()).length() * 1.5;
            camera.position.set(center.x + dist, center.y + dist/2, center.z + dist);
            controls.target.copy(center);
        }

        // --- ì„ íƒ ì‹œ ë°˜íˆ¬ëª… ê°•ì¡° ê¸°ëŠ¥ ---
        function setHighlight(selectedTarget) {
            parts.forEach(p => {
                p.traverse(node => {
                    if (node.isMesh) {
                        if (selectedTarget && p === selectedTarget) {
                            node.material.transparent = false;
                            node.material.opacity = 1.0;
                        } else if (selectedTarget) {
                            node.material.transparent = true;
                            node.material.opacity = 0.2;
                        } else {
                            node.material.transparent = false;
                            node.material.opacity = 1.0;
                        }
                    }
                });
            });
        }

        // ì„ íƒ ì´ë²¤íŠ¸
        window.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return; // í´ë¦­ ì‹œì ì˜ ì‹œì  ì´ë™ ë°©í•´ ê¸ˆì§€
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(parts, true);
            if (intersects.length > 0) {
                let target = intersects[0].object;
                while(target && !parts.includes(target)) { target = target.parent; }
                if (target) {
                    outlinePass.selectedObjects = [target];

                    document.getElementById('part-name').innerText = target.userData.title;
                    document.getElementById('part-desc').innerText = target.userData.desc;

                    if (nameEl) nameEl.innerText = target.userData.title;
                    if (descEl) descEl.innerText = target.userData.desc;

                    setHighlight(target);
                }
            } else {
                outlinePass.selectedObjects = [];
                setHighlight(null);
                
                const nameEl = document.getElementById('part-name');
                const descEl = document.getElementById('part-desc');

                // ì„ íƒ í•´ì œ ì‹œ ì›ë˜ ì—ì…‹ ì´ë¦„(CONFIG.assetName)ìœ¼ë¡œ ë³µêµ¬
                if (nameEl) nameEl.innerText = CONFIG.assetName; 
                if (descEl) descEl.innerText = "ë¶€í’ˆì„ í´ë¦­í•˜ì—¬ ìƒì„¸ ì •ë³´ë¥¼ í™•ì¸í•˜ì„¸ìš”.";   
               
            }
        });

        // partsê°€ ì•„ë‹Œ ì¤‘ë³µ ì œê±°ëœ ë¶€ëª¨ ë¶€í’ˆ ë¦¬ìŠ¤íŠ¸(uniqueLogicalParts)ë¥¼ ëŒë ¤ì•¼ í•©ë‹ˆë‹¤.
        document.getElementById('explode-slider').addEventListener('input', (e) => {
            const val = e.target.value / 100;
            uniqueLogicalParts.forEach(p => {
                if (p.userData.explodeDir && p.userData.assemblyPos) {
                    // ë¶€ëª¨ ì˜¤ë¸Œì íŠ¸(BASE, NUT ë“±)ë¥¼ ì§ì ‘ ì´ë™
                    const move = p.userData.explodeDir.clone().multiplyScalar(val * 0.3);
                    p.position.copy(p.userData.assemblyPos).add(move);
                }
            });
        });

        // WASD ì´ë™
        const keys = { w:false, a:false, s:false, d:false };
        window.addEventListener('keydown', e => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) keys[key] = true;
        });

        window.addEventListener('keyup', e => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) keys[key] = false;
        });

        window.addEventListener('blur', () => {
             Object.keys(keys).forEach(k => keys[k] = false);
        });


        function handleKeyboardMove() {
            const speed = 0.01;
            const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd); fwd.y = 0; fwd.normalize();
            const right = new THREE.Vector3().crossVectors(camera.up, fwd).normalize();
            const delta = new THREE.Vector3();
            if(keys.w) delta.addScaledVector(fwd, speed);
            if(keys.s) delta.addScaledVector(fwd, -speed);
            if(keys.a) delta.addScaledVector(right, speed);
            if(keys.d) delta.addScaledVector(right, -speed);
            camera.position.add(delta);
            controls.target.add(delta);
        }

        loadAsset();

        function animate() {
            requestAnimationFrame(animate);
            handleKeyboardMove();
            controls.update();
            composer.render();
        }
        animate();

        window.addEventListener('resize', () => { 
            const w = container.clientWidth; const h = container.clientHeight;
            camera.aspect = w / h; camera.updateProjectionMatrix(); 
            renderer.setSize(w, h); composer.setSize(w, h);
        });
    </script>
</body>
</html>