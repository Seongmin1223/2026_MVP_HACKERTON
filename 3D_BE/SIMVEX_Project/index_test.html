<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SIMVEX - Integrated Viewer</title>
    <style>
        /* --- ê¸°ë³¸ ìŠ¤íƒ€ì¼ --- */
        :root { --bg-dark: #0f1014; --bg-panel: rgba(20, 22, 28, 0.9); --accent-color: #3b82f6; --text-main: #ffffff; --text-sub: #a1a1aa; --border-color: #27272a; }
        body { margin: 0; overflow: hidden; background-color: var(--bg-dark); color: var(--text-main); font-family: 'Pretendard', sans-serif; }
        
        #app-container { display: grid; grid-template-rows: 60px 1fr; grid-template-columns: 1fr 350px; height: 100vh; width: 100vw; }
        
        /* í—¤ë” */
        header { grid-column: 1 / -1; background: var(--bg-dark); border-bottom: 1px solid var(--border-color); display: flex; align-items: center; padding: 0 24px; font-weight: bold; font-size: 1.2rem; z-index: 10; }
        #viewport { position: relative; background: linear-gradient(135deg, #18181b 0%, #09090b 100%); overflow: hidden; width: 100%; height: 100%; }
        #viewport canvas { outline: none; }
        #viewport-overlay {
            position: absolute; bottom: 20px; left: 20px;
            background: rgba(0,0,0,0.6); padding: 12px 16px; border-radius: 8px;
            pointer-events: none; /* í´ë¦­ì´ í†µê³¼ë˜ë„ë¡ ì„¤ì • */
            font-size: 0.85rem; color: #ccc; backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 100;
        }
        .kbd { background: #333; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; color: white; border-bottom: 2px solid #111; font-family: monospace; }
        .guide-title { font-weight: bold; color: white; margin-bottom: 6px; }

        /* íŒ¨ë„ (ì‚¬ì´ë“œë°”) */
        aside { background: var(--bg-panel); border-left: 1px solid var(--border-color); padding: 24px; display: flex; flex-direction: column; gap: 24px; overflow-y: auto; }
        h3 { margin: 0 0 12px 0; font-size: 0.9rem; color: var(--accent-color); text-transform: uppercase; }
        
        /* ìŠ¬ë¼ì´ë” */
        .slider-container { margin-top: 10px; display: flex; align-items: center; gap: 10px; }
        input[type=range] { flex-grow: 1; accent-color: var(--accent-color); cursor: pointer; }
        
        /* ë¡œë”© í™”ë©´ */
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--accent-color); font-size: 1.2rem; font-weight: bold; }
    </style>
</head>
<body>

    <div id="app-container">
        <header><div style="color:#3b82f6; margin-right:20px;">SIMVEX</div> Integrated Mode</header>
        
        <div id="viewport">
            <div id="loading">ë°ì´í„° ë¡œë”© ì¤‘</div>
            
            <div id="viewport-overlay">
                <div class="guide-title">ğŸ® ì¡°ì‘ ê°€ì´ë“œ</div>
                <div>â€¢ <span class="kbd">WASD</span> : ì¹´ë©”ë¼ ì´ë™</div>
                <div>â€¢ <span class="kbd">ìš°í´ë¦­</span> : í™”ë©´ íšŒì „</div>
                <div>â€¢ <span class="kbd">ì¢Œí´ë¦­</span> : ë¶€í’ˆ ì„ íƒ</div>
                <div>â€¢ <span class="kbd">íœ </span> : ì¤Œ ì¸/ì•„ì›ƒ</div>
            </div>
        </div>
        <aside>
            <div>
                <h3>ğŸ“¦ Part Info</h3>
                <h2 id="part-name">Loading</h2>
                <p id="part-desc">ëª¨ë¸ ë°ì´í„°ë¥¼ ë¶„ì„í•˜ê³  ìˆìŠµë‹ˆë‹¤.</p>
                <div id="debug-log" style="margin-top:10px; color:yellow; font-size:0.8rem; white-space: pre-line;"></div>
            </div>
            <div>
                <h3>ğŸ”§ Exploded View</h3>
                <div class="slider-container">
                    <span>ì¡°ë¦½</span>
                    <input type="range" id="explode-slider" min="0" max="100" value="0">
                    <span>ë¶„í•´</span>
                </div>
            </div>
        </aside>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        const container = document.getElementById('viewport');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.01, 1000);
        camera.position.set(0.1, 0.1, 0.2); // ì´ˆê¸° ì¹´ë©”ë¼ ìœ„ì¹˜

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        container.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(1, 2, 1);
        scene.add(dirLight);

        // Controls (OrbitControls)
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        controls.mouseButtons = {
            LEFT: THREE.MOUSE.PAN,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.ROTATE
        };

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let parts = [];
        async function loadIntegratedModel() {
            const loadingEl = document.getElementById('loading');
            const debugEl = document.getElementById('debug-log');
            
            try {
                const res = await fetch('./3D_data.json');
                const data = await res.json();
                
                const loader = new GLTFLoader();
                const glbPath = data.base_path + data.integrated_file;

                loader.load(glbPath, (gltf) => {
                    const root = gltf.scene;
                    scene.add(root);

                    /*console.log("=== GLB ë‚´ë¶€ ë¶€í’ˆ ëª©ë¡ ===");
                    let realNames = [];
                    root.traverse((child) => {
                        if (child.isMesh) {
                            console.log(`ì´ë¦„: ${child.name}`);
                            realNames.push(child.name);
                        }
                    });*/ //ë””ë²„ê¹… ì½”ë“œë‹ˆê¹Œ ì‹ ê²½ì“°ì§€ ë§ê²ƒ

                    let matchCount = 0;
                    data.assets.forEach(asset => {
                        const part = root.getObjectByName(asset.id);
                        if (part) {
                            matchCount++;
                            part.userData = {
                                id: asset.id,
                                title: asset.title,
                                desc: asset.desc,
                                assemblyPos: part.position.clone()
                            };
                            part.castShadow = true;
                            part.receiveShadow = true;
                            parts.push(part);
                        }
                    });

                    loadingEl.style.display = 'none';

                    if (matchCount > 0) {
                        document.getElementById('part-name').innerText = data.project_name;
                        document.getElementById('part-desc').innerText = `${matchCount}ê°œì˜ ë¶€í’ˆì´ ì—°ë™ë˜ì—ˆìŠµë‹ˆë‹¤.`;
                        calculateExplosion(parts, root);
                        fitCamera(root);
                    } else {
                        document.getElementById('part-name').innerText = "ë§¤ì¹­ ì‹¤íŒ¨";
                        document.getElementById('part-desc').innerText = "JSON IDë¥¼ í™•ì¸";
                        debugEl.innerText = "ì½˜ì†”(F12)ì—ì„œ ì‹¤ì œ ë¶€í’ˆ ì´ë¦„ì„ í™•ì¸í•˜ê³ \n3D_data.jsonì˜ id ìˆ˜ì •";
                    }

                }, undefined, (err) => {
                    console.error(err);
                    loadingEl.innerText = "GLB ë¡œë“œ ì‹¤íŒ¨ (ê²½ë¡œ í™•ì¸)";
                });

            } catch (err) {
                console.error(err);
                loadingEl.innerText = "JSON ë¡œë“œ ì‹¤íŒ¨";
            }
        }

        function calculateExplosion(partList, root) {
            const box = new THREE.Box3().setFromObject(root);
            const center = new THREE.Vector3();
            box.getCenter(center);

            partList.forEach(part => {
                const pBox = new THREE.Box3().setFromObject(part);
                const pCenter = new THREE.Vector3();
                pBox.getCenter(pCenter);

                let dir = new THREE.Vector3().subVectors(pCenter, center);
                if(dir.length() < 0.0001) dir.set(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5);
                dir.normalize();
                part.userData.explodeDir = dir;
            });
        }

        function fitCamera(object) {
            const box = new THREE.Box3().setFromObject(object);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const dist = maxDim * 2.5; 
            
            camera.position.set(center.x + dist, center.y + dist/2, center.z + dist);
            camera.lookAt(center);
            controls.target.copy(center);
            controls.update();
        }

        loadIntegratedModel();
        document.getElementById('explode-slider').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value) / 100;
            const SCALE = 0.15; 

            parts.forEach(part => {
                if(part.userData.assemblyPos) {
                    const move = part.userData.explodeDir.clone().multiplyScalar(val * SCALE);
                    part.position.copy(part.userData.assemblyPos).add(move);
                }
            });
        });

        // ë¶€í’ˆ ì„ íƒ ë¶€ë¶„
        let downTime = 0;
        window.addEventListener('mousedown', () => { downTime = Date.now(); });
        window.addEventListener('mouseup', (e) => {
            if (Date.now() - downTime > 200) return; // 200ms ì´ìƒ ëˆ„ë¥´ë©´ ë“œë˜ê·¸ë¡œ ê°„ì£¼

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(parts, true);
            if (intersects.length > 0) {
                let target = intersects[0].object;
                while(target) {
                    if (parts.includes(target)) break;
                    target = target.parent;
                }

                if (target) {
                    document.getElementById('part-name').innerText = target.userData.title;
                    document.getElementById('part-desc').innerText = target.userData.desc;
                    
                    target.traverse(c => {
                        if(c.isMesh) {
                            if(!c.userData.orgMat) c.userData.orgMat = c.material;
                            const m = c.material.clone();
                            m.emissive.setHex(0x3b82f6);
                            m.emissiveIntensity = 0.5;
                            c.material = m;
                        }
                    });
                    setTimeout(() => {
                         target.traverse(c => { if(c.isMesh && c.userData.orgMat) c.material = c.userData.orgMat; });
                    }, 500);
                }
            }
        });

        //wasd í‚¤ë³´ë“œ ë¡œì§
        const keys = { w:false, a:false, s:false, d:false };
        window.addEventListener('keydown', e => { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = true; });
        window.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false; });

        function handleKeyboardMove() {
            const speed = 0.005; // ì´ë™ ì†ë„
            
            // ì¹´ë©”ë¼ê°€ ë°”ë¼ë³´ëŠ” ë°©í–¥ ê³„ì‚°
            const fwd = new THREE.Vector3(); 
            camera.getWorldDirection(fwd); 
            fwd.y = 0; // ë†’ì´ëŠ” ìœ ì§€í•˜ê³  ìˆ˜í‰ ì´ë™ë§Œ
            fwd.normalize();

            // ì˜¤ë¥¸ìª½ ë°©í–¥ ê³„ì‚°
            const right = new THREE.Vector3();
            right.crossVectors(camera.up, fwd).normalize();

            if(keys.w) camera.position.addScaledVector(fwd, speed);
            if(keys.s) camera.position.addScaledVector(fwd, -speed);
            if(keys.a) camera.position.addScaledVector(right, -speed); // ì™¼ìª½
            if(keys.d) camera.position.addScaledVector(right, speed);  // ì˜¤ë¥¸ìª½
            
            controls.target.addScaledVector(fwd, 0);
        }

        function animate() {
            requestAnimationFrame(animate);
            handleKeyboardMove();
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => { 
            camera.aspect = container.clientWidth/container.clientHeight; 
            camera.updateProjectionMatrix(); 
            renderer.setSize(container.clientWidth, container.clientHeight); 
        });
    </script>
</body>
</html>